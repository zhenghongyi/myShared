去年开始重构公司的邮件业务，目标是输出 SDK 可交付给客户对接。在将邮件逻辑部分抽出后，剩下业务界面交互的部分要进行模块化划分，但模块之间怎么的通信，是一个问题。参考过网上流行的几个方案，有以下几个看法：

1. URL跳转方案灵活适用性强，但对于复杂的数据和操作，效率不是很高；
2. 反射机制方案利用 OC 特色的反射机制，也是很灵活，但会存在许多的硬编码，并且反射机制自身就有效率问题；
3. 复杂数据经常使用 Dictionary 类型来代为传递，需要转换和解析的过程，并且这也使得传参的参数类型不明朗；
4. block 类型参数无法传递。

同时客户对 SDK 的要求中，会有部分界面需要定制或者交由宿主工程（即客户的系统）进行处理。

基于以上几点，自己设计了一个试用自己项目的路由跳转方案，以下为示例：

```
public struct Contact {}

public protocol RouteParameter {}

public protocol ContactService {
    func contactSelections(params:[RouteParameter], response:(([Contact]) -> Void)?) throws -> UIViewController
    func otherService(params:[RouteParameter]) throws -> UIViewController
}

public class Route {
    public enum RouteError: Error {
        case noRelevantService
    }
    
    private static let shared:Route = Route()
    
    private var contactService:ContactService?
    
    public static func configure(contactService:ContactService?) {
        shared.contactService = contactService
    }
    
    static func contactSelections(params:[RouteParameter], response:(([Contact]) -> Void)?) throws -> UIViewController {
        guard let service = shared.contactService else { throw RouteError.noRelevantService }
        return try service.contactSelections(params: params, response: response)
    }
}

/// 联系人模块实现的服务协议
enum ContactRouteParameter: RouteParameter {
    case token(token:String)
    case selection(selecteds:[Contact], forbidens:[Contact], maxCount:Int, filter:((Contact) -> Bool)?)
    case other
}

struct ContactModuleService: ContactService {
    enum ContactServiceError: Error {
        case missParam(String)
    }
    
    func contactSelections(params: [RouteParameter], response: (([Contact]) -> Void)?) throws -> UIViewController {
        let controller = ContactSelectionController()
        for item in params {
            if let rp = item as? ContactRouteParameter {
                switch rp {
                case .token(let token):
                    controller.token = token
                case .selection(let selecteds, let forbidens, let maxCount, let filter):
                    controller.selecteds = selecteds
                    controller.forbidens = forbidens
                    controller.maxCount = maxCount
                    controller.filter = filter
                default:
                    print("多余的参数：\(rp)")
                }
            }
        }
        controller.completion = response
        if controller.token == nil {
            throw ContactServiceError.missParam("token")
        }
        return controller
    }
    
    func otherService(params: [RouteParameter]) throws -> UIViewController {
        return UIViewController()
    }
}

/// 联系人模块所提供的交互界面
class ContactSelectionController: UIViewController {
    var token:String?

    var selecteds:[Contact] = []
    var forbidens:[Contact] = []
    var maxCount:Int = Int.max
    var filter:((Contact) -> Bool)?
    var completion:(([Contact]) -> Void)?
}
```
项目的结构为

```
|- MailService
|	|- Contact
|- MailUI
|	|- ContactUI
|	| 	|- Service
|	|	|	|- ContactRouteParameter
|	|	|	|- ContactModuleService
|	|	|- UI
|	|	|	|- ContactSelectionController
|- Route
```

这个方案的思路是，以 Swift 的 enum 作为参数，支持各种类型的参数传递，包括 block；各个模块定义自己的服务，到 Route 进行综合调用；这些服务大体都以 params（参数）、recalls（回调）、UIViewController（结果界面）这三者组成。

Route 提供路由跳转功能，所需要的模块各自调用 Route 中提供的服务方法；宿主项目在入口处对 Route 进行配置；如果某些需要自己实现的界面，宿主项目可以自行实现协议，然后再配置到 Route 中，就可以拦截到；不用协议中的所有方法都重写实现，不需要重写的部分，嵌套重用对应 SDK 提供的服务就行。

Route 依赖于 MailService 的对象具体模型，但如果考虑通用性的话，可以用泛型来代替具体的模型。